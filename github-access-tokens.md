# Explanation for how we use GitHub access tokens with Probot

Many of the applications in this repository use the [Probot](https://probot.github.io/) framework to power GitHub apps.
In the source code of some of these apps (e.g., `bundle-size`) you will notice that we define an environment variable
called `GITHUB_ACCESS_TOKEN`, which should be set to a [personal access token](https://github.com/settings/tokens)
generated by the user:

###### [bundle-size/.env.example](https://github.com/ampproject/amp-github-apps/blob/33969c884f51a5fcfe342202b1935145b64efd1b/bundle-size/.env.example#L25-L26)
```sh
# A GitHub user access token that can read team members
ACCESS_TOKEN=0123456789abcdef0123456789abcdef01234567
```

###### [bundle-size/app.js](https://github.com/ampproject/amp-github-apps/blob/7a66567ae24b6061d5078d97e8a2f9816b68e0a0/bundle-size/app.js#L31-L35)
```javascript
  const userBasedGithub = new Octokit({
    'auth': process.env.ACCESS_TOKEN,
  });

  const githubUtils = new GitHubUtils(userBasedGithub, app.log);
```

An experienced GitHub Apps developer would wonder why this is necessary, as GitHub Apps have their own way to
authenticate themselves with the GitHub API, using the App ID and its private key, which we also provide as environment
variables:

###### [bundle-size/.env.example](https://github.com/ampproject/amp-github-apps/blob/33969c884f51a5fcfe342202b1935145b64efd1b/bundle-size/.env.example#L1-L11)
```sh
# The ID of your GitHub App
APP_ID=12345
# Base64 encoded private key from GitHub
PRIVATE_KEY=0123456789abcdefghijklmnopqrstuvwxyz
```

And, in fact, we use both approaches!

Inside Probot Webhook handlers, the `context` object has a `github` field that is already authenticated to perform API
calls with the permissions given to the app:

###### [bundle-size/webhooks.js](https://github.com/ampproject/amp-github-apps/blob/33969c884f51a5fcfe342202b1935145b64efd1b/bundle-size/webhooks.js#L42)

```javascript
      },
    });
    const check = await context.github.checks.create(params);

    const checkRunId = check.data.id;
```

Whereas in other contexts we use the `githubUtils` object that we authenticated using the personal access token:

###### [bundle-size/app.js](https://github.com/ampproject/amp-github-apps/blob/33969c884f51a5fcfe342202b1935145b64efd1b/bundle-size/webhooks.js#L96)
```javascript
    }

    const isSuperApprover = await githubUtils.isSuperApprover(approver);
    context.log(
      `Approving user ${approver} of pull request ${pullRequestId}`,
```

## So why the duality?

Unfortunately, the GitHub API permission scopes are confusing and not always in line with the documentation.

There is currently no way, for example, to get read-only access to organization teams and their members as a GitHub App
(only full administration permissions can be given to an app), but it is possible using a personal access token of a
member of the organization, if that access token was given the `read:org` permission.

Contrary, it is not currently possible to assign a reviewer to a pull request with a personal access token, but it is
possible to do so with an app that was given the appropriate `pull requests` permission.
